{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "autocomplete",
  "type": "registry:ui",
  "dependencies": [
    "@radix-ui/react-slot",
    "cmdk",
    "lucide-react"
  ],
  "registryDependencies": [
    "command",
    "https://akasha-ui.pages.dev/r/styles/default/input.json"
  ],
  "files": [
    {
      "path": "ui/autocomplete.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { Command as CommandPrimitive } from \"cmdk\";\nimport { Check, Loader2 } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/registry/default/ui/command\";\nimport { Input } from \"@/registry/default/ui/input\";\n\nconst AutocompleteContext = React.createContext<\n  | ((\n      | {\n          multiple: true;\n          onValueChange?: (value: string[]) => void;\n        }\n      | { multiple?: false; onValueChange?: (value: string) => void }\n    ) & {\n      searchValue: string;\n      open: boolean;\n      emptyMessage: string;\n      loading?: boolean;\n      inputRef: React.RefObject<HTMLInputElement | null>;\n      selectedValues: string[];\n      setSearchValue: React.Dispatch<React.SetStateAction<string>>;\n      setOpen: React.Dispatch<React.SetStateAction<boolean>>;\n      registerOption: (value: string, label: React.ReactNode) => void;\n    })\n  | null\n>(null);\n\nconst useAutocompleteContext = () => {\n  const context = React.useContext(AutocompleteContext);\n  if (!context) {\n    throw new Error(\n      \"`useAutocompleteContext` must be used within `Autocomplete`\"\n    );\n  }\n  return context;\n};\n\nconst Autocomplete = ({\n  emptyMessage = \"\",\n  loading = false,\n  className,\n  children,\n  ...props\n}: {\n  emptyMessage?: string;\n  loading?: boolean;\n  children?: React.ReactNode;\n  className?: string;\n} & (\n  | {\n      multiple: true;\n      value?: string[];\n      onValueChange?: (value: string[]) => void;\n    }\n  | {\n      multiple?: false;\n      value?: string;\n      onValueChange?: (value: string) => void;\n    }\n)) => {\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [open, setOpen] = React.useState(false);\n  const [searchValue, setSearchValue] = React.useState(\"\");\n  const [options, setOptions] = React.useState<Record<string, React.ReactNode>>(\n    {}\n  );\n\n  const registerOption = React.useCallback(\n    (value: string, label: React.ReactNode) => {\n      setOptions((prev) => ({ ...prev, [value]: label }));\n    },\n    []\n  );\n\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (!inputRef.current) return;\n\n      const { multiple, value = [], onValueChange } = props;\n\n      if (!open) setOpen(true);\n\n      if (event.key === \"Escape\") {\n        inputRef.current.blur();\n        return;\n      }\n\n      if (event.key !== \"Enter\" || !inputRef.current.value) return;\n\n      const selectedValue = Object.keys(options).find((key) => {\n        const optionLabel = options[key];\n        return (\n          typeof optionLabel === \"string\" &&\n          optionLabel.toLowerCase() === inputRef.current!.value.toLowerCase()\n        );\n      });\n\n      if (!selectedValue) return;\n\n      if (multiple) {\n        const newSelected = new Set(Array.isArray(value) ? value : []);\n        newSelected.add(selectedValue);\n        onValueChange?.([...newSelected]);\n      } else {\n        onValueChange?.(selectedValue);\n      }\n    },\n    [open, options, props, setOpen]\n  );\n\n  return (\n    <AutocompleteContext.Provider\n      value={{\n        ...props,\n        searchValue,\n        emptyMessage,\n        open,\n        selectedValues: props.multiple\n          ? (props.value ?? [])\n          : props.value\n            ? [props.value]\n            : [],\n        loading,\n        inputRef,\n        setOpen,\n        setSearchValue,\n        registerOption,\n      }}\n    >\n      <Command\n        data-slot=\"autocomplete\"\n        onKeyDown={handleKeyDown}\n        className={cn(\n          \"relative flex flex-col gap-2 bg-transparent rounded-lg text-sm overflow-visible\",\n          className\n        )}\n      >\n        <div className=\"hidden\">\n          <CommandInput value={searchValue} />\n        </div>\n        {children}\n      </Command>\n    </AutocompleteContext.Provider>\n  );\n};\n\nconst AutocompleteTrigger = ({\n  asChild,\n  ...props\n}:\n  | { asChild: true; children?: React.ReactNode }\n  | (React.ComponentProps<\"input\"> & {\n      asChild?: false;\n    })) => {\n  const { searchValue, setSearchValue, setOpen, inputRef, multiple } =\n    useAutocompleteContext();\n\n  const Comp = asChild ? Slot : Input;\n\n  const handleBlur = React.useCallback(() => {\n    setOpen(false);\n    if (!multiple) {\n      setSearchValue(searchValue || \"\");\n    }\n  }, [setOpen, setSearchValue, searchValue, multiple]);\n\n  return (\n    <Comp\n      data-slot=\"autocomplete-trigger\"\n      ref={inputRef}\n      value={searchValue}\n      type=\"search\"\n      onChange={(event) => {\n        setSearchValue(event.target.value);\n        setOpen(true);\n      }}\n      onFocus={() => {\n        setOpen(true);\n      }}\n      onBlur={() => {\n        handleBlur();\n      }}\n      {...props}\n    />\n  );\n};\n\nconst AutocompleteList = ({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof CommandList>) => {\n  const { open, loading, emptyMessage } = useAutocompleteContext();\n\n  return (\n    <CommandList\n      data-slot=\"autocomplete-list\"\n      className={cn(\n        \"absolute top-11 animate-in fade-in-0 zoom-in-95 z-10 w-full border rounded-lg bg-card p-1\",\n        {\n          hidden: !open,\n        },\n        !emptyMessage && \"has-[[data-slot='command-group'][hidden]]:hidden\",\n        className\n      )}\n      {...props}\n    >\n      {loading && (\n        <CommandPrimitive.Loading className=\"flex justify-center p-1\">\n          <Loader2 className=\"animate-spin\" />\n        </CommandPrimitive.Loading>\n      )}\n      {!loading && emptyMessage && (\n        <CommandEmpty className=\"flex justify-center p-2\">\n          {emptyMessage}\n        </CommandEmpty>\n      )}\n      {!loading && <CommandGroup>{children}</CommandGroup>}\n    </CommandList>\n  );\n};\n\nconst AutocompleteItem = ({\n  value,\n  children,\n  className,\n  onMouseDown,\n  onSelect,\n  ...props\n}: {\n  children: React.ReactNode;\n  value: string;\n} & React.ComponentProps<typeof CommandItem>) => {\n  const {\n    selectedValues,\n    setSearchValue,\n    setOpen,\n    registerOption,\n    multiple,\n    onValueChange,\n  } = useAutocompleteContext();\n\n  React.useEffect(() => {\n    registerOption(value, children);\n  }, [value, children, registerOption]);\n\n  const isSelected = selectedValues.includes(value);\n\n  const searchValue = typeof children === \"string\" ? children : value;\n\n  const handleSelect = () => {\n    if (multiple) {\n      const newSelected = isSelected\n        ? selectedValues.filter((item) => item !== value)\n        : [...selectedValues, value];\n\n      onValueChange?.(newSelected);\n    } else {\n      onValueChange?.(value);\n      setSearchValue(searchValue);\n      setOpen(false);\n    }\n  };\n\n  return (\n    <CommandItem\n      data-slot=\"autocomplete-item\"\n      value={searchValue}\n      onMouseDown={(event) => {\n        event.preventDefault();\n        event.stopPropagation();\n        onMouseDown?.(event);\n      }}\n      onSelect={(value) => {\n        handleSelect();\n        onSelect?.(value);\n      }}\n      className={cn(\n        \"flex w-full items-center gap-2\",\n        !isSelected && \"pl-8\",\n        className\n      )}\n      {...props}\n    >\n      {isSelected && <Check className=\"w-4 text-current\" />}\n      {children}\n    </CommandItem>\n  );\n};\n\nexport {\n  Autocomplete,\n  AutocompleteTrigger,\n  AutocompleteList,\n  AutocompleteItem,\n};\n",
      "type": "registry:ui"
    }
  ]
}