{
  "name": "use-scroll-restoration",
  "type": "registry:hook",
  "files": [
    {
      "path": "hooks/use-scroll-restoration.ts",
      "content": "import * as React from \"react\";\nimport { Virtualizer, VirtualizerOptions } from \"@tanstack/react-virtual\";\n\nconst SCROLL_RESTORATION_CONFIG = \"scroll-restoration-config\";\n\ntype Config = {\n  /*\n   * The last scroll offset position\n   **/\n  scrollOffset: number;\n  /*\n   * The offset of the parent container holding the virtual list\n   **/\n  topOffset: number;\n  /*\n   * Index of the reference item used for scroll restoration\n   **/\n  referenceItemIndex: number;\n  /*\n   * Virtualizer's options\n   **/\n  options: VirtualizerOptions<Window, Element>;\n  /*\n   * Last scroll restoration session key used to either reset the scroll restoration config\n   * if the current key and the one before do not match or to use the scroll config.\n   **/\n  lastScrollRestorationKey: string;\n  /*\n   * Height of a header element in a virtual list\n   **/\n  headerHeight?: number;\n  /*\n   * Flag to check if a scroll restoration is done\n   **/\n  done?: boolean;\n} & { [key: string]: unknown };\n\ninterface IRestoreScrollPosition {\n  virtualizer: Virtualizer<Window, Element>;\n  overScan: number;\n  offsetAttribute: string;\n  scrollRestorationStorageKey: string;\n}\n\n/*\n * Restore scroll position\n **/\nasync function restoreScrollPosition({\n  virtualizer,\n  overScan,\n  offsetAttribute,\n  scrollRestorationStorageKey,\n}: IRestoreScrollPosition) {\n  try {\n    const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n    if (!scrollConfig) return;\n    const { referenceItemIndex, topOffset, scrollOffset, options, done } =\n      scrollConfig;\n    /*\n     * Validate scroll restoration config fields\n     **/\n    if (\n      typeof referenceItemIndex !== \"number\" ||\n      !options ||\n      typeof options !== \"object\" ||\n      typeof scrollOffset !== \"number\"\n    )\n      return;\n\n    const scrollIndex = options.initialMeasurementsCache?.findIndex(\n      (measurementCache) => measurementCache.index === referenceItemIndex\n    );\n\n    if (scrollIndex && scrollIndex !== -1) {\n      const currentTopOffset =\n        virtualizer.getVirtualItems()?.[0]?.start -\n        virtualizer.options.scrollMargin;\n      /*\n       * Check if the latest virtual items container offset matches with the current offset to determine\n       * if the current offset can be used for scroll restoration.\n       **/\n      const offsetMatched =\n        Number(\n          document\n            .querySelector(`[${offsetAttribute}]`)\n            ?.getAttribute(offsetAttribute)\n        ) === currentTopOffset && typeof currentTopOffset === \"number\";\n\n      /*\n       * Check if all conditions for scroll restoration are satisfied.\n       **/\n      if (\n        requiredItemsLoaded({ virtualizer, scrollIndex, overScan, options }) &&\n        offsetMatched &&\n        !done\n      ) {\n        /*\n         * Check the difference between the last offset of the virtual list container with the current one.\n         * If there is a difference add or subtract from the last scroll offset to determine the normalized scroll restoration offset.\n         **/\n        const offsetDelta = topOffset - currentTopOffset;\n        const scrollToOffset =\n          typeof offsetDelta === \"number\"\n            ? scrollOffset - offsetDelta\n            : scrollOffset;\n        virtualizer.scrollToOffset(scrollToOffset, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n        if (scrollToOffset !== virtualizer.scrollOffset) {\n          setTimeout(() => {\n            virtualizer.scrollToOffset(scrollToOffset, {\n              align: \"start\",\n              behavior: \"auto\",\n            });\n          }, 0);\n        }\n        storeScrollConfig(scrollRestorationStorageKey, {\n          ...scrollConfig,\n          done: true,\n        });\n        setTimeout(() => {\n          removeItemFromScrollConfig(scrollRestorationStorageKey);\n        }, 500);\n      }\n    }\n  } catch (error) {\n    console.error(error);\n    removeItemFromScrollConfig(scrollRestorationStorageKey);\n  }\n}\n\n/*\n * Restore scroll config\n **/\nfunction restoreScrollConfig(\n  scrollRestorationStorageKey?: string\n): Config | null {\n  try {\n    const config = JSON.parse(\n      sessionStorage.getItem(SCROLL_RESTORATION_CONFIG) || \"\"\n    );\n    return scrollRestorationStorageKey\n      ? config[scrollRestorationStorageKey]\n      : config;\n  } catch (e) {\n    return null;\n  }\n}\n\n/*\n * Store scroll restoration configuration\n **/\nfunction storeScrollConfig(\n  scrollRestorationStorageKey: string,\n  config: Config\n) {\n  const currentConfig = restoreScrollConfig();\n  sessionStorage.setItem(\n    SCROLL_RESTORATION_CONFIG,\n    JSON.stringify({\n      ...(currentConfig ? currentConfig : {}),\n      [scrollRestorationStorageKey]: config,\n    })\n  );\n}\n\n/*\n * Remove item from scroll config by key\n **/\nfunction removeItemFromScrollConfig(key: string) {\n  const config = restoreScrollConfig();\n\n  if (config) {\n    delete config[key];\n    sessionStorage.setItem(SCROLL_RESTORATION_CONFIG, JSON.stringify(config));\n  }\n}\n\ninterface IItemsLoaded {\n  virtualizer: Virtualizer<Window, Element>;\n  scrollIndex: number;\n  overScan: number;\n  options: VirtualizerOptions<Window, Element>;\n}\n\n/*\n * Check if all required items for scroll restoration are loaded.\n **/\nfunction requiredItemsLoaded({\n  virtualizer,\n  scrollIndex,\n  overScan,\n  options,\n}: IItemsLoaded) {\n  /*\n   * Find the visible item used as a scroll restoration reference.\n   **/\n  const referenceItem = virtualizer\n    .getVirtualItems()\n    .find((virtualItem) => virtualItem.index === scrollIndex);\n\n  /*\n   * Create array of steps to take back from the reference item to check if\n   * the virtual items before it are loaded according to the appropriate size.\n   **/\n  const stepBackArr = Array(overScan)\n    .fill(0)\n    .map((_, index) => index + 1);\n\n  /*\n   * Check if the reference item is loaded according to the appropriate size.\n   **/\n  const referenceItemLoaded =\n    referenceItem &&\n    referenceItem.size >=\n      (options.initialMeasurementsCache?.[referenceItem.index]?.size || 0);\n\n  /*\n   * Check if items before the visible reference item are loaded according to the appropriate size.\n   **/\n  const itemsBeforeReferenceItemLoaded = stepBackArr\n    .map((stepBack) => {\n      const prevItem = virtualizer\n        .getVirtualItems()\n        .find((virtualItem) => virtualItem.index === scrollIndex - stepBack);\n      return prevItem\n        ? prevItem.size >=\n            (options.initialMeasurementsCache?.[prevItem.index]?.size || 0)\n        : true;\n    })\n    .every((item) => item);\n\n  return referenceItemLoaded && itemsBeforeReferenceItemLoaded;\n}\n\nconst getHeaderHeight = ({\n  scrollRestorationStorageKey,\n  lastScrollRestorationKey,\n}: {\n  scrollRestorationStorageKey: string;\n  lastScrollRestorationKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n  if (!scrollConfig || typeof scrollConfig !== \"object\") return null;\n  if (\n    scrollConfig.lastScrollRestorationKey &&\n    lastScrollRestorationKey !== scrollConfig.lastScrollRestorationKey\n  )\n    return null;\n  return typeof scrollConfig.headerHeight === \"number\"\n    ? scrollConfig.headerHeight\n    : null;\n};\n\nconst getInitialMeasurementsCache = ({\n  scrollRestorationStorageKey,\n}: {\n  scrollRestorationStorageKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n  if (\n    !scrollConfig ||\n    typeof scrollConfig !== \"object\" ||\n    typeof scrollConfig.options !== \"object\"\n  )\n    return [];\n  return scrollConfig.options.initialMeasurementsCache;\n};\n\ninterface IScrollRestoration {\n  /*\n   * Virtualizer's instance\n   **/\n  virtualizer: Virtualizer<Window, Element>;\n  /*\n   * The total number of items virtualized\n   **/\n  count: number;\n  /*\n   * The number of items rendered above and below the visible area\n   **/\n  overScan: number;\n  /*\n   * Scroll restoration session storage key\n   **/\n  scrollRestorationStorageKey: string;\n  /*\n   * Last scroll restoration session key used to either reset the scroll restoration config\n   * if the current key and the one before do not match or to use the scroll config.\n   **/\n  lastScrollRestorationKey: string;\n  /*\n   * The offset attribute for the virtual list container\n   **/\n  offsetAttribute: string;\n  /*\n   * Reference to a header element in a virtual list\n   **/\n  headerRef?: React.RefObject<HTMLDivElement>;\n}\n\n/*\n * Restores the last scroll position\n * @param virtualizer - instance of virtualizer\n **/\nexport function useScrollRestoration({\n  virtualizer,\n  count,\n  overScan,\n  scrollRestorationStorageKey,\n  lastScrollRestorationKey,\n  offsetAttribute,\n  headerRef,\n}: IScrollRestoration) {\n  const virtualizerRef = React.useRef(virtualizer);\n  const overScanRef = React.useRef(overScan);\n  const offsetAttributeRef = React.useRef(offsetAttribute);\n  const scrollRestorationStorageKeyRef = React.useRef(\n    scrollRestorationStorageKey\n  );\n  const lastScrollRestorationKeyRef = React.useRef(lastScrollRestorationKey);\n  const headerHeightRef = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    const observer = new ResizeObserver(() => {\n      headerHeightRef.current =\n        headerRef?.current?.getBoundingClientRect()?.height || 0;\n    });\n    if (headerRef?.current) {\n      observer.observe(headerRef.current);\n    }\n    return () => {\n      observer.disconnect();\n    };\n  }, [headerRef]);\n\n  React.useEffect(() => {\n    virtualizerRef.current = virtualizer;\n  }, [virtualizer]);\n\n  React.useEffect(() => {\n    const virtualizer = virtualizerRef.current;\n    const scrollConfig = restoreScrollConfig(\n      scrollRestorationStorageKeyRef.current\n    );\n    if (scrollConfig) {\n      const { referenceItemIndex, options, done, lastScrollRestorationKey } =\n        scrollConfig;\n\n      /*\n       * If the current lastScrollRestorationKey and the one before do not match then prevent initiating scroll restoration\n       **/\n      if (\n        lastScrollRestorationKey &&\n        lastScrollRestorationKey !== lastScrollRestorationKeyRef.current\n      ) {\n        removeItemFromScrollConfig(scrollRestorationStorageKeyRef.current);\n        return;\n      }\n\n      if (\n        !options ||\n        typeof referenceItemIndex !== \"number\" ||\n        typeof options !== \"object\" ||\n        count < options.count ||\n        done\n      )\n        return;\n\n      /*\n       * Find the index of an item which will be used as a scroll restoration reference.\n       **/\n      const scrollIndex = options.initialMeasurementsCache?.findIndex(\n        (measurementCache) => measurementCache.index === referenceItemIndex\n      );\n      if (scrollIndex && scrollIndex !== -1) {\n        /*\n         * Make sure virtualizer's options from last scroll position are available in the current virtualizer instance\n         * before scrolling to the index of the reference item.\n         **/\n        virtualizer.setOptions({\n          ...virtualizer.options,\n          ...options,\n        });\n        virtualizer.scrollToIndex(scrollIndex, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n      }\n    }\n  }, [count]);\n\n  React.useEffect(() => {\n    const overScan = overScanRef.current;\n    const scrollRestorationStorageKey = scrollRestorationStorageKeyRef.current;\n    const lastScrollRestorationKey = lastScrollRestorationKeyRef.current;\n    const scrollOffset = virtualizerRef.current?.scrollOffset || 0;\n    /*\n     * Store scroll restoration configs after unmounting the component where the scroll restoration is used.\n     **/\n    return () => {\n      /*\n       * Store scroll restoration config only if a scroll occurred\n       **/\n      if (scrollOffset > 0) {\n        const headerHeight = headerHeightRef.current;\n        const virtualItems = virtualizerRef.current.getVirtualItems();\n        const stepBackArr = Array(overScan)\n          .fill(0)\n          .map((_, index) => index);\n        /*\n         * Compute a visible item which will be used for scroll restoration reference.\n         **/\n        let visibleItem = null;\n        for (const stepBack of stepBackArr) {\n          if (virtualItems?.[overScan - stepBack]) {\n            visibleItem = virtualItems[overScan - stepBack];\n            break;\n          }\n        }\n        /*\n         * If the index of the visible item is less than or equal to overScan recompute the visible item for accuracy\n         **/\n        if (visibleItem && visibleItem.index <= overScan) {\n          let visibleItemIndex = virtualItems.findIndex(\n            (virtualItem) =>\n              virtualItem.start >= (virtualizerRef.current.scrollOffset || 0)\n          );\n          visibleItemIndex = visibleItemIndex === 0 ? 0 : visibleItemIndex - 1;\n          if (visibleItemIndex >= 0) {\n            visibleItem = virtualItems[visibleItemIndex];\n          }\n        }\n\n        storeScrollConfig(scrollRestorationStorageKey, {\n          scrollOffset,\n          topOffset:\n            virtualItems?.[0]?.start -\n            virtualizerRef.current.options.scrollMargin,\n          referenceItemIndex: visibleItem?.index || 0,\n          options: {\n            ...virtualizerRef.current?.options,\n            initialMeasurementsCache: virtualizerRef.current?.measurementsCache,\n          },\n          lastScrollRestorationKey,\n          headerHeight: headerHeight || 0,\n        });\n      }\n    };\n  }, []);\n\n  React.useEffect(() => {\n    const scrollConfig = restoreScrollConfig(\n      scrollRestorationStorageKeyRef.current\n    );\n\n    /*\n     * Observe changes in the dimension of body element to check scroll position restoration requirements and if all check passes commit the restoration.\n     **/\n    const observer = new ResizeObserver(() => {\n      restoreScrollPosition({\n        virtualizer: virtualizerRef.current,\n        overScan: overScanRef.current,\n        offsetAttribute: offsetAttributeRef.current,\n        scrollRestorationStorageKey: scrollRestorationStorageKeyRef.current,\n      });\n    });\n    if (scrollConfig) observer.observe(document.body);\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n}\n\nexport {\n  restoreScrollPosition,\n  restoreScrollConfig,\n  getHeaderHeight,\n  getInitialMeasurementsCache,\n};\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}