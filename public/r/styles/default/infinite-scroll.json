{
  "name": "infinite-scroll",
  "type": "registry:ui",
  "dependencies": [
    "@tanstack/react-virtual"
  ],
  "registryDependencies": [
    "https://akasha-ui.pages.dev/r/styles/default/stack.json"
  ],
  "files": [
    {
      "path": "ui/infinite-scroll.tsx",
      "content": "import * as React from \"react\";\nimport {\n  measureElement,\n  useWindowVirtualizer,\n  Virtualizer,\n} from \"@tanstack/react-virtual\";\n\nimport { cn } from \"@/lib/utils\";\nimport { useIsMobile } from \"@/registry/default/hooks/use-mobile\";\nimport {\n  getHeaderHeight,\n  getInitialMeasurementsCache,\n  useScrollRestoration,\n} from \"@/registry/default/hooks/use-scroll-restoration\";\nimport { Stack } from \"@/registry/default/ui/stack\";\n\nconst InfiniteScrollContext = React.createContext<{\n  listOffset: number;\n  itemSpacing?: number;\n  estimatedHeight: number;\n  loading?: boolean;\n  hasNextPage?: boolean;\n  virtualizer: Virtualizer<Window, Element>;\n  count: number;\n  overScan: number;\n  headerRef: React.RefObject<HTMLDivElement | null>;\n} | null>(null);\n\nconst useInfiniteScrollContext = () => {\n  const context = React.useContext(InfiniteScrollContext);\n  if (!context) {\n    throw new Error(\n      \"`useInfiniteScrollContext` must be used within `InfiniteScroll`\"\n    );\n  }\n  return context;\n};\n\nconst InfiniteScroll = ({\n  count,\n  estimatedHeight,\n  lanes,\n  overScan = 5,\n  itemSpacing,\n  hasNextPage,\n  loading,\n  header,\n  className,\n  children,\n  onLoadMore,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  count: number;\n  estimatedHeight: number;\n  lanes?: number;\n  overScan?: number;\n  itemSpacing?: number;\n  hasNextPage?: boolean;\n  loading?: boolean;\n  header?: React.ReactNode;\n  onLoadMore?: () => void;\n}) => {\n  const parentRef = React.useRef<HTMLDivElement>(null);\n  const parentOffsetRef = React.useRef(0);\n  const headerRef = React.useRef<HTMLDivElement>(null);\n  const isMobile = useIsMobile();\n\n  React.useLayoutEffect(() => {\n    parentOffsetRef.current = parentRef.current?.offsetTop ?? 0;\n  }, [parentRef.current?.offsetTop]);\n\n  const virtualizer = useWindowVirtualizer({\n    count,\n    lanes,\n    overscan: overScan,\n    gap: itemSpacing,\n    scrollMargin: parentOffsetRef.current,\n    measureElement: isMobile\n      ? (element, entry, instance) => {\n          const dataIndex = instance.indexFromElement(element);\n          if (\n            instance.scrollDirection === \"backward\" &&\n            instance.measurementsCache?.[dataIndex]\n          ) {\n            return instance.measurementsCache[dataIndex].size;\n          }\n          return measureElement(element, entry, instance);\n        }\n      : measureElement,\n    estimateSize: () => estimatedHeight,\n  });\n\n  const virtualItems = virtualizer.getVirtualItems();\n  const totalSize = virtualizer.getTotalSize();\n\n  const vListOffset = virtualItems?.[0]?.start\n    ? virtualItems[0].start - virtualizer.options.scrollMargin\n    : 0;\n\n  const minHeight =\n    virtualizer.isScrolling && loading && hasNextPage\n      ? totalSize + overScan * estimatedHeight\n      : totalSize;\n\n  React.useEffect(() => {\n    if (!hasNextPage || loading) return;\n\n    const lastItem = virtualItems[virtualItems.length - 1];\n    if (lastItem && lastItem.index >= count - 1) {\n      const timeout = setTimeout(() => {\n        onLoadMore?.();\n      }, 100);\n      return () => clearTimeout(timeout);\n    }\n  }, [hasNextPage, count, loading, virtualItems, onLoadMore]);\n\n  return (\n    <>\n      {header && <div ref={headerRef}>{header}</div>}\n      <div\n        data-slot=\"infinite-scroll\"\n        ref={parentRef}\n        className={cn(\"relative w-full\", className)}\n        style={{\n          minHeight: `${minHeight}px`,\n        }}\n        {...props}\n      >\n        <InfiniteScrollContext.Provider\n          value={{\n            listOffset: vListOffset,\n            itemSpacing,\n            estimatedHeight,\n            loading,\n            hasNextPage,\n            virtualizer,\n            count,\n            overScan,\n            headerRef,\n          }}\n        >\n          {children}\n        </InfiniteScrollContext.Provider>\n      </div>\n    </>\n  );\n};\n\nconst InfiniteScrollList = ({\n  loadingIndicator,\n  className,\n  children,\n  ...props\n}: Omit<React.ComponentProps<\"div\">, \"children\"> & {\n  loadingIndicator?: React.ReactNode;\n  children: (index: number) => React.ReactElement<any>;\n}) => {\n  const {\n    listOffset,\n    itemSpacing,\n    estimatedHeight,\n    loading,\n    hasNextPage,\n    virtualizer,\n  } = useInfiniteScrollContext();\n\n  const virtualItems = virtualizer.getVirtualItems();\n  const { initialMeasurementsCache } = virtualizer.options;\n  return (\n    <Stack\n      data-slot=\"infinite-scroll-list\"\n      data-offset={listOffset}\n      className={cn(\"absolute w-full top-0 left-0\", className)}\n      style={{\n        transform: `translateY(${listOffset}px)`,\n        gap: `${itemSpacing}px`,\n      }}\n      {...props}\n    >\n      {virtualItems.map((virtualItem) => {\n        const cachedSize =\n          initialMeasurementsCache?.[virtualItem.index]?.size || 0;\n        const minHeight = loading ? estimatedHeight : cachedSize;\n\n        return (\n          <div\n            key={virtualItem.key}\n            data-index={virtualItem.index}\n            ref={virtualizer.measureElement}\n            style={{\n              ...(minHeight && {\n                minHeight: `${minHeight}px`,\n              }),\n            }}\n          >\n            {children(virtualItem.index)}\n          </div>\n        );\n      })}\n      {loading && hasNextPage && virtualItems.length > 0 && loadingIndicator}\n    </Stack>\n  );\n};\n\nconst ScrollRestoration = (\n  props: React.PropsWithChildren<{\n    offsetAttribute: string;\n    scrollRestorationStorageKey?: string;\n    lastScrollRestorationKey?: string;\n  }>\n) => {\n  const {\n    scrollRestorationStorageKey = \"storage-key\",\n    lastScrollRestorationKey,\n    offsetAttribute,\n    children,\n  } = props;\n\n  const { count, overScan, headerRef, virtualizer } =\n    useInfiniteScrollContext();\n\n  virtualizer.setOptions({\n    ...virtualizer.options,\n    initialMeasurementsCache: getInitialMeasurementsCache({\n      scrollRestorationStorageKey,\n    }),\n  });\n\n  React.useLayoutEffect(() => {\n    const headerHeight = getHeaderHeight({\n      scrollRestorationStorageKey,\n      lastScrollRestorationKey: lastScrollRestorationKey ?? \"\",\n    });\n    if (headerHeight)\n      headerRef.current?.setAttribute(\n        \"className\",\n        `${headerRef.current.className} min-h-[${headerHeight}px]`\n      );\n  }, [headerRef, lastScrollRestorationKey, scrollRestorationStorageKey]);\n\n  useScrollRestoration({\n    virtualizer,\n    count,\n    overScan,\n    scrollRestorationStorageKey,\n    offsetAttribute,\n    lastScrollRestorationKey: lastScrollRestorationKey ?? \"\",\n    headerRef,\n  });\n  return <>{children}</>;\n};\n\nexport { InfiniteScroll, InfiniteScrollList, ScrollRestoration };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "hooks/use-scroll-restoration.ts",
      "content": "import * as React from \"react\";\nimport { Virtualizer, VirtualizerOptions } from \"@tanstack/react-virtual\";\n\nconst SCROLL_RESTORATION_CONFIG = \"scroll-restoration-config\";\n\ntype Config = {\n  /*\n   * The last scroll offset position\n   **/\n  scrollOffset: number;\n  /*\n   * The offset of the parent container holding the virtual list\n   **/\n  topOffset: number;\n  /*\n   * Index of the reference item used for scroll restoration\n   **/\n  referenceItemIndex: number;\n  /*\n   * Virtualizer's options\n   **/\n  options: VirtualizerOptions<Window, Element>;\n  /*\n   * Last scroll restoration session key used to either reset the scroll restoration config\n   * if the current key and the one before do not match or to use the scroll config.\n   **/\n  lastScrollRestorationKey: string;\n  /*\n   * Height of a header element in a virtual list\n   **/\n  headerHeight?: number;\n  /*\n   * Flag to check if a scroll restoration is done\n   **/\n  done?: boolean;\n} & { [key: string]: unknown };\n\ninterface IRestoreScrollPosition {\n  virtualizer: Virtualizer<Window, Element>;\n  overScan: number;\n  offsetAttribute: string;\n  scrollRestorationStorageKey: string;\n}\n\n/*\n * Restore scroll position\n **/\nasync function restoreScrollPosition({\n  virtualizer,\n  overScan,\n  offsetAttribute,\n  scrollRestorationStorageKey,\n}: IRestoreScrollPosition) {\n  try {\n    const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n    if (!scrollConfig) return;\n    const { referenceItemIndex, topOffset, scrollOffset, options, done } =\n      scrollConfig;\n    /*\n     * Validate scroll restoration config fields\n     **/\n    if (\n      typeof referenceItemIndex !== \"number\" ||\n      !options ||\n      typeof options !== \"object\" ||\n      typeof scrollOffset !== \"number\"\n    )\n      return;\n\n    const scrollIndex = options.initialMeasurementsCache?.findIndex(\n      (measurementCache) => measurementCache.index === referenceItemIndex\n    );\n\n    if (scrollIndex && scrollIndex !== -1) {\n      const currentTopOffset =\n        virtualizer.getVirtualItems()?.[0]?.start -\n        virtualizer.options.scrollMargin;\n      /*\n       * Check if the latest virtual items container offset matches with the current offset to determine\n       * if the current offset can be used for scroll restoration.\n       **/\n      const offsetMatched =\n        Number(\n          document\n            .querySelector(`[${offsetAttribute}]`)\n            ?.getAttribute(offsetAttribute)\n        ) === currentTopOffset && typeof currentTopOffset === \"number\";\n\n      /*\n       * Check if all conditions for scroll restoration are satisfied.\n       **/\n      if (\n        requiredItemsLoaded({ virtualizer, scrollIndex, overScan, options }) &&\n        offsetMatched &&\n        !done\n      ) {\n        /*\n         * Check the difference between the last offset of the virtual list container with the current one.\n         * If there is a difference add or subtract from the last scroll offset to determine the normalized scroll restoration offset.\n         **/\n        const offsetDelta = topOffset - currentTopOffset;\n        const scrollToOffset =\n          typeof offsetDelta === \"number\"\n            ? scrollOffset - offsetDelta\n            : scrollOffset;\n        virtualizer.scrollToOffset(scrollToOffset, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n        if (scrollToOffset !== virtualizer.scrollOffset) {\n          setTimeout(() => {\n            virtualizer.scrollToOffset(scrollToOffset, {\n              align: \"start\",\n              behavior: \"auto\",\n            });\n          }, 0);\n        }\n        storeScrollConfig(scrollRestorationStorageKey, {\n          ...scrollConfig,\n          done: true,\n        });\n        setTimeout(() => {\n          removeItemFromScrollConfig(scrollRestorationStorageKey);\n        }, 500);\n      }\n    }\n  } catch (error) {\n    console.error(error);\n    removeItemFromScrollConfig(scrollRestorationStorageKey);\n  }\n}\n\n/*\n * Restore scroll config\n **/\nfunction restoreScrollConfig(\n  scrollRestorationStorageKey?: string\n): Config | null {\n  try {\n    const config = JSON.parse(\n      sessionStorage.getItem(SCROLL_RESTORATION_CONFIG) || \"\"\n    );\n    return scrollRestorationStorageKey\n      ? config[scrollRestorationStorageKey]\n      : config;\n  } catch (e) {\n    return null;\n  }\n}\n\n/*\n * Store scroll restoration configuration\n **/\nfunction storeScrollConfig(\n  scrollRestorationStorageKey: string,\n  config: Config\n) {\n  const currentConfig = restoreScrollConfig();\n  sessionStorage.setItem(\n    SCROLL_RESTORATION_CONFIG,\n    JSON.stringify({\n      ...(currentConfig ? currentConfig : {}),\n      [scrollRestorationStorageKey]: config,\n    })\n  );\n}\n\n/*\n * Remove item from scroll config by key\n **/\nfunction removeItemFromScrollConfig(key: string) {\n  const config = restoreScrollConfig();\n\n  if (config) {\n    delete config[key];\n    sessionStorage.setItem(SCROLL_RESTORATION_CONFIG, JSON.stringify(config));\n  }\n}\n\ninterface IItemsLoaded {\n  virtualizer: Virtualizer<Window, Element>;\n  scrollIndex: number;\n  overScan: number;\n  options: VirtualizerOptions<Window, Element>;\n}\n\n/*\n * Check if all required items for scroll restoration are loaded.\n **/\nfunction requiredItemsLoaded({\n  virtualizer,\n  scrollIndex,\n  overScan,\n  options,\n}: IItemsLoaded) {\n  /*\n   * Find the visible item used as a scroll restoration reference.\n   **/\n  const referenceItem = virtualizer\n    .getVirtualItems()\n    .find((virtualItem) => virtualItem.index === scrollIndex);\n\n  /*\n   * Create array of steps to take back from the reference item to check if\n   * the virtual items before it are loaded according to the appropriate size.\n   **/\n  const stepBackArr = Array(overScan)\n    .fill(0)\n    .map((_, index) => index + 1);\n\n  /*\n   * Check if the reference item is loaded according to the appropriate size.\n   **/\n  const referenceItemLoaded =\n    referenceItem &&\n    referenceItem.size >=\n      (options.initialMeasurementsCache?.[referenceItem.index]?.size || 0);\n\n  /*\n   * Check if items before the visible reference item are loaded according to the appropriate size.\n   **/\n  const itemsBeforeReferenceItemLoaded = stepBackArr\n    .map((stepBack) => {\n      const prevItem = virtualizer\n        .getVirtualItems()\n        .find((virtualItem) => virtualItem.index === scrollIndex - stepBack);\n      return prevItem\n        ? prevItem.size >=\n            (options.initialMeasurementsCache?.[prevItem.index]?.size || 0)\n        : true;\n    })\n    .every((item) => item);\n\n  return referenceItemLoaded && itemsBeforeReferenceItemLoaded;\n}\n\nconst getHeaderHeight = ({\n  scrollRestorationStorageKey,\n  lastScrollRestorationKey,\n}: {\n  scrollRestorationStorageKey: string;\n  lastScrollRestorationKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n  if (!scrollConfig || typeof scrollConfig !== \"object\") return null;\n  if (\n    scrollConfig.lastScrollRestorationKey &&\n    lastScrollRestorationKey !== scrollConfig.lastScrollRestorationKey\n  )\n    return null;\n  return typeof scrollConfig.headerHeight === \"number\"\n    ? scrollConfig.headerHeight\n    : null;\n};\n\nconst getInitialMeasurementsCache = ({\n  scrollRestorationStorageKey,\n}: {\n  scrollRestorationStorageKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollRestorationStorageKey);\n  if (\n    !scrollConfig ||\n    typeof scrollConfig !== \"object\" ||\n    typeof scrollConfig.options !== \"object\"\n  )\n    return [];\n  return scrollConfig.options.initialMeasurementsCache;\n};\n\ninterface IScrollRestoration {\n  /*\n   * Virtualizer's instance\n   **/\n  virtualizer: Virtualizer<Window, Element>;\n  /*\n   * The total number of items virtualized\n   **/\n  count: number;\n  /*\n   * The number of items rendered above and below the visible area\n   **/\n  overScan: number;\n  /*\n   * Scroll restoration session storage key\n   **/\n  scrollRestorationStorageKey: string;\n  /*\n   * Last scroll restoration session key used to either reset the scroll restoration config\n   * if the current key and the one before do not match or to use the scroll config.\n   **/\n  lastScrollRestorationKey: string;\n  /*\n   * The offset attribute for the virtual list container\n   **/\n  offsetAttribute: string;\n  /*\n   * Reference to a header element in a virtual list\n   **/\n  headerRef?: React.RefObject<HTMLDivElement | null>;\n}\n\n/*\n * Restores the last scroll position\n * @param virtualizer - instance of virtualizer\n **/\nexport function useScrollRestoration({\n  virtualizer,\n  count,\n  overScan,\n  scrollRestorationStorageKey,\n  lastScrollRestorationKey,\n  offsetAttribute,\n  headerRef,\n}: IScrollRestoration) {\n  const virtualizerRef = React.useRef(virtualizer);\n  const overScanRef = React.useRef(overScan);\n  const offsetAttributeRef = React.useRef(offsetAttribute);\n  const scrollRestorationStorageKeyRef = React.useRef(\n    scrollRestorationStorageKey\n  );\n  const lastScrollRestorationKeyRef = React.useRef(lastScrollRestorationKey);\n  const headerHeightRef = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    const observer = new ResizeObserver(() => {\n      headerHeightRef.current =\n        headerRef?.current?.getBoundingClientRect()?.height || 0;\n    });\n    if (headerRef?.current) {\n      observer.observe(headerRef.current);\n    }\n    return () => {\n      observer.disconnect();\n    };\n  }, [headerRef]);\n\n  React.useEffect(() => {\n    virtualizerRef.current = virtualizer;\n  }, [virtualizer]);\n\n  React.useEffect(() => {\n    const virtualizer = virtualizerRef.current;\n    const scrollConfig = restoreScrollConfig(\n      scrollRestorationStorageKeyRef.current\n    );\n    if (scrollConfig) {\n      const { referenceItemIndex, options, done, lastScrollRestorationKey } =\n        scrollConfig;\n\n      /*\n       * If the current lastScrollRestorationKey and the one before do not match then prevent initiating scroll restoration\n       **/\n      if (\n        lastScrollRestorationKey &&\n        lastScrollRestorationKey !== lastScrollRestorationKeyRef.current\n      ) {\n        removeItemFromScrollConfig(scrollRestorationStorageKeyRef.current);\n        return;\n      }\n\n      if (\n        !options ||\n        typeof referenceItemIndex !== \"number\" ||\n        typeof options !== \"object\" ||\n        count < options.count ||\n        done\n      )\n        return;\n\n      /*\n       * Find the index of an item which will be used as a scroll restoration reference.\n       **/\n      const scrollIndex = options.initialMeasurementsCache?.findIndex(\n        (measurementCache) => measurementCache.index === referenceItemIndex\n      );\n      if (scrollIndex && scrollIndex !== -1) {\n        /*\n         * Make sure virtualizer's options from last scroll position are available in the current virtualizer instance\n         * before scrolling to the index of the reference item.\n         **/\n        virtualizer.setOptions({\n          ...virtualizer.options,\n          ...options,\n        });\n        virtualizer.scrollToIndex(scrollIndex, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n      }\n    }\n  }, [count]);\n\n  React.useEffect(() => {\n    const overScan = overScanRef.current;\n    const scrollRestorationStorageKey = scrollRestorationStorageKeyRef.current;\n    const lastScrollRestorationKey = lastScrollRestorationKeyRef.current;\n    const scrollOffset = virtualizerRef.current?.scrollOffset || 0;\n    /*\n     * Store scroll restoration configs after unmounting the component where the scroll restoration is used.\n     **/\n    return () => {\n      /*\n       * Store scroll restoration config only if a scroll occurred\n       **/\n      if (scrollOffset > 0) {\n        const headerHeight = headerHeightRef.current;\n        const virtualItems = virtualizerRef.current.getVirtualItems();\n        const stepBackArr = Array(overScan)\n          .fill(0)\n          .map((_, index) => index);\n        /*\n         * Compute a visible item which will be used for scroll restoration reference.\n         **/\n        let visibleItem = null;\n        for (const stepBack of stepBackArr) {\n          if (virtualItems?.[overScan - stepBack]) {\n            visibleItem = virtualItems[overScan - stepBack];\n            break;\n          }\n        }\n        /*\n         * If the index of the visible item is less than or equal to overScan recompute the visible item for accuracy\n         **/\n        if (visibleItem && visibleItem.index <= overScan) {\n          let visibleItemIndex = virtualItems.findIndex(\n            (virtualItem) =>\n              virtualItem.start >= (virtualizerRef.current.scrollOffset || 0)\n          );\n          visibleItemIndex = visibleItemIndex === 0 ? 0 : visibleItemIndex - 1;\n          if (visibleItemIndex >= 0) {\n            visibleItem = virtualItems[visibleItemIndex];\n          }\n        }\n\n        storeScrollConfig(scrollRestorationStorageKey, {\n          scrollOffset,\n          topOffset:\n            virtualItems?.[0]?.start -\n            virtualizerRef.current.options.scrollMargin,\n          referenceItemIndex: visibleItem?.index || 0,\n          options: {\n            ...virtualizerRef.current?.options,\n            initialMeasurementsCache: virtualizerRef.current?.measurementsCache,\n          },\n          lastScrollRestorationKey,\n          headerHeight: headerHeight || 0,\n        });\n      }\n    };\n  }, []);\n\n  React.useEffect(() => {\n    const scrollConfig = restoreScrollConfig(\n      scrollRestorationStorageKeyRef.current\n    );\n\n    /*\n     * Observe changes in the dimension of body element to check scroll position restoration requirements and if all check passes commit the restoration.\n     **/\n    const observer = new ResizeObserver(() => {\n      restoreScrollPosition({\n        virtualizer: virtualizerRef.current,\n        overScan: overScanRef.current,\n        offsetAttribute: offsetAttributeRef.current,\n        scrollRestorationStorageKey: scrollRestorationStorageKeyRef.current,\n      });\n    });\n    if (scrollConfig) observer.observe(document.body);\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n}\n\nexport {\n  restoreScrollPosition,\n  restoreScrollConfig,\n  getHeaderHeight,\n  getInitialMeasurementsCache,\n};\n",
      "type": "registry:hook",
      "target": ""
    },
    {
      "path": "hooks/use-mobile.tsx",
      "content": "import * as React from \"react\";\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\n    undefined\n  );\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener(\"change\", onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return !!isMobile;\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}