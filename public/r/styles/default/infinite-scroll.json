{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-scroll",
  "type": "registry:ui",
  "dependencies": [
    "@tanstack/react-virtual"
  ],
  "files": [
    {
      "path": "ui/infinite-scroll.tsx",
      "content": "import * as React from \"react\";\nimport {\n  measureElement,\n  useVirtualizer,\n  useWindowVirtualizer,\n  Virtualizer,\n} from \"@tanstack/react-virtual\";\n\nimport { cn } from \"@/lib/utils\";\nimport { useIsMobile } from \"@/registry/default/hooks/use-mobile\";\nimport {\n  getHeaderHeight,\n  getInitialMeasurementsCache,\n  useScrollRestoration,\n} from \"@/registry/default/hooks/use-scroll-restoration\";\n\nconst InfiniteScrollContext = React.createContext<{\n  gap?: number;\n  loading?: boolean;\n  hasNextPage?: boolean;\n  virtualizer:\n    | Virtualizer<Window, Element>\n    | Virtualizer<HTMLDivElement, Element>;\n  count: number;\n  overScan: number;\n  headerRef: React.RefObject<HTMLDivElement | null>;\n  loadingIndicator?: React.ReactNode;\n} | null>(null);\n\nconst useInfiniteScrollContext = () => {\n  const context = React.useContext(InfiniteScrollContext);\n  if (!context) {\n    throw new Error(\n      \"`useInfiniteScrollContext` must be used within `InfiniteScroll`\"\n    );\n  }\n  return context;\n};\n\nconst InfiniteScroll = ({\n  count,\n  estimatedHeight,\n  lanes,\n  overScan = 5,\n  gap,\n  header,\n  hasNextPage,\n  loading,\n  loadingIndicator,\n  scrollElementType = \"window\",\n  className,\n  children,\n  onLoadMore,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  count: number;\n  estimatedHeight: number;\n  lanes?: number;\n  overScan?: number;\n  gap?: number;\n  header?: React.ReactNode;\n  hasNextPage?: boolean;\n  loading?: boolean;\n  loadingIndicator?: React.ReactNode;\n  scrollElementType?: \"window\" | \"element\";\n  onLoadMore?: () => void;\n}) => {\n  const parentRef = React.useRef<HTMLDivElement>(null);\n  const parentOffsetRef = React.useRef(0);\n  const headerRef = React.useRef<HTMLDivElement>(null);\n  const isMobile = useIsMobile();\n\n  React.useLayoutEffect(() => {\n    parentOffsetRef.current = parentRef.current?.offsetTop ?? 0;\n  }, [parentRef.current?.offsetTop]);\n\n  const commonOptions = {\n    count,\n    lanes,\n    overscan: overScan,\n    gap,\n    scrollMargin: parentOffsetRef.current,\n    measureElement: isMobile\n      ? (\n          element: any,\n          entry: ResizeObserverEntry | undefined,\n          instance: Virtualizer<any, any>\n        ) => {\n          const dataIndex = instance.indexFromElement(element);\n          if (\n            instance.scrollDirection === \"backward\" &&\n            instance.measurementsCache?.[dataIndex]\n          ) {\n            return instance.measurementsCache[dataIndex].size;\n          }\n          return measureElement(element, entry, instance);\n        }\n      : measureElement,\n    estimateSize: () => estimatedHeight,\n  };\n\n  const windowVirtualizer = useWindowVirtualizer(commonOptions);\n\n  const elementVirtualizer = useVirtualizer({\n    ...commonOptions,\n    getScrollElement: () => parentRef.current,\n  });\n\n  const virtualizer =\n    scrollElementType === \"window\" ? windowVirtualizer : elementVirtualizer;\n\n  const virtualItems = virtualizer.getVirtualItems();\n  const totalSize = virtualizer.getTotalSize();\n\n  const minHeight =\n    virtualizer.isScrolling && loading && hasNextPage\n      ? totalSize + overScan * estimatedHeight\n      : totalSize;\n\n  React.useEffect(() => {\n    if (!hasNextPage || loading) return;\n\n    const lastItem = virtualItems[virtualItems.length - 1];\n    if (lastItem && lastItem.index >= count - 1) {\n      onLoadMore?.();\n    }\n  }, [hasNextPage, count, loading, virtualItems, onLoadMore]);\n\n  return (\n    <>\n      {header && <div ref={headerRef}>{header}</div>}\n      <div\n        ref={parentRef}\n        data-slot=\"infinite-scroll-container\"\n        className={cn(\n          \"w-full\",\n          scrollElementType === \"element\" && \"overflow-y-auto h-100\"\n        )}\n      >\n        <div\n          data-slot=\"infinite-scroll\"\n          className={cn(\"relative w-full\", className)}\n          style={{\n            minHeight: `${minHeight}px`,\n          }}\n          {...props}\n        >\n          <InfiniteScrollContext.Provider\n            value={{\n              gap,\n              loading,\n              hasNextPage,\n              virtualizer,\n              count,\n              overScan,\n              loadingIndicator,\n              headerRef,\n            }}\n          >\n            {children}\n          </InfiniteScrollContext.Provider>\n        </div>\n      </div>\n    </>\n  );\n};\n\nconst InfiniteScrollList = ({\n  className,\n  children,\n  ...props\n}: Omit<React.ComponentProps<\"div\">, \"children\"> & {\n  children: (index: number) => React.ReactElement<any>;\n}) => {\n  const { gap, loading, hasNextPage, virtualizer, loadingIndicator } =\n    useInfiniteScrollContext();\n\n  const virtualItems = virtualizer.getVirtualItems();\n  const listOffset = virtualItems?.[0]?.start\n    ? virtualItems[0].start - virtualizer.options.scrollMargin\n    : 0;\n\n  return (\n    <div\n      data-slot=\"infinite-scroll-list\"\n      data-offset={listOffset}\n      className={cn(\"flex flex-col absolute w-full top-0 left-0\", className)}\n      style={{\n        transform: `translateY(${listOffset}px)`,\n        gap: `${gap}px`,\n      }}\n      {...props}\n    >\n      {virtualItems.map((virtualItem) => {\n        return (\n          <div\n            key={virtualItem.key}\n            ref={virtualizer.measureElement}\n            data-index={virtualItem.index}\n          >\n            {children(virtualItem.index)}\n          </div>\n        );\n      })}\n      {loading && hasNextPage && virtualItems.length > 0 && loadingIndicator}\n    </div>\n  );\n};\n\nconst isWindowVirtualizer = (\n  virtualizer: Virtualizer<any, Element>\n): virtualizer is Virtualizer<Window, Element> =>\n  virtualizer.scrollElement instanceof Window;\n\nconst WindowScrollRestoration = ({\n  scrollConfigStorageKey = \"storage-key\",\n  lastScrollRestorationKey = \"\",\n  virtualizer,\n  children,\n}: React.PropsWithChildren<{\n  scrollConfigStorageKey?: string;\n  lastScrollRestorationKey?: string;\n  virtualizer: Virtualizer<Window, Element>;\n}>) => {\n  const { count, overScan, headerRef } = useInfiniteScrollContext();\n\n  React.useEffect(() => {\n    if (isWindowVirtualizer(virtualizer)) {\n      virtualizer.setOptions({\n        ...virtualizer.options,\n        initialMeasurementsCache: getInitialMeasurementsCache({\n          scrollConfigStorageKey,\n        }),\n      });\n    }\n  }, [scrollConfigStorageKey, virtualizer]);\n\n  React.useLayoutEffect(() => {\n    const headerHeight = getHeaderHeight({\n      scrollConfigStorageKey,\n      lastScrollRestorationKey,\n    });\n    if (headerHeight)\n      headerRef.current?.setAttribute(\n        \"className\",\n        `${headerRef.current.className} min-h-[${headerHeight}px]`\n      );\n  }, [headerRef, lastScrollRestorationKey, scrollConfigStorageKey]);\n\n  useScrollRestoration({\n    virtualizer,\n    count,\n    overScan,\n    scrollConfigStorageKey,\n    offsetAttribute: \"data-offset\",\n    lastScrollRestorationKey,\n    headerRef,\n  });\n  return <>{children}</>;\n};\n\nconst ScrollRestoration = ({\n  children,\n  ...props\n}: React.PropsWithChildren<{\n  scrollConfigStorageKey?: string;\n  lastScrollRestorationKey?: string;\n}>) => {\n  const { virtualizer } = useInfiniteScrollContext();\n\n  if (isWindowVirtualizer(virtualizer))\n    return (\n      <WindowScrollRestoration virtualizer={virtualizer} {...props}>\n        {children}\n      </WindowScrollRestoration>\n    );\n\n  throw new Error(\n    \"Scroll restoration is currently only supported when the scroll element is the window.\"\n  );\n};\n\nexport { InfiniteScroll, InfiniteScrollList, ScrollRestoration };\n",
      "type": "registry:ui"
    },
    {
      "path": "hooks/use-scroll-restoration.ts",
      "content": "import * as React from \"react\";\nimport { Virtualizer, VirtualizerOptions } from \"@tanstack/react-virtual\";\n\nconst SCROLL_RESTORATION_CONFIG = \"scroll-restoration-config\";\n\ntype ScrollRestoration = {\n  /*\n   * Virtualizer's instance.\n   **/\n  virtualizer: Virtualizer<Window, Element>;\n  /*\n   * The total number of items to virtualize.\n   **/\n  count: number;\n  /*\n   * The number of items to render above and below the visible area.\n   **/\n  overScan: number;\n  /*\n   * Key used to store scroll restoration configuration.\n   **/\n  scrollConfigStorageKey: string;\n  /*\n   * Last scroll restoration prevents scroll restoration unless the user navigates back to the last key they visited.\n   **/\n  lastScrollRestorationKey: string;\n  /*\n   * The offset attribute for the virtual list container.\n   **/\n  offsetAttribute: string;\n  /*\n   * Reference to a header element in a virtual list.\n   **/\n  headerRef?: React.RefObject<HTMLDivElement | null>;\n};\n\ntype Config = {\n  /*\n   * The last scroll offset position.\n   **/\n  lastScrollOffset: number;\n  /*\n   * The offset of the parent container holding the virtual list.\n   **/\n  topOffset: number;\n  /*\n   * Index of the reference item used for scroll restoration.\n   **/\n  referenceItemIndex: number;\n  /*\n   * Virtualizer's options\n   **/\n  options: VirtualizerOptions<Window, Element>;\n  /*\n   * Height of a header element in a virtual list.\n   **/\n  headerHeight?: number;\n  /*\n   * Flag to check if a scroll restoration is done.\n   **/\n  done?: boolean;\n} & { [key: string]: unknown } & Pick<\n    ScrollRestoration,\n    \"lastScrollRestorationKey\"\n  >;\n\ninterface IRestoreScrollPosition {\n  virtualizer: Virtualizer<Window, Element>;\n  overScan: number;\n  offsetAttribute: string;\n  scrollConfigStorageKey: string;\n}\n\n/*\n * Restore scroll position\n **/\nasync function restoreScrollPosition({\n  virtualizer,\n  overScan,\n  offsetAttribute,\n  scrollConfigStorageKey,\n}: IRestoreScrollPosition) {\n  try {\n    const scrollConfig = restoreScrollConfig(scrollConfigStorageKey);\n    if (!scrollConfig) return;\n    const { referenceItemIndex, topOffset, lastScrollOffset, options, done } =\n      scrollConfig;\n    /*\n     * Validate scroll restoration config fields\n     **/\n    if (\n      typeof referenceItemIndex !== \"number\" ||\n      !options ||\n      typeof options !== \"object\" ||\n      typeof lastScrollOffset !== \"number\"\n    )\n      return;\n\n    const scrollIndex = options.initialMeasurementsCache?.findIndex(\n      (measurementCache) => measurementCache.index === referenceItemIndex\n    );\n\n    if (scrollIndex && scrollIndex !== -1) {\n      const currentTopOffset =\n        virtualizer.getVirtualItems()?.[0]?.start -\n        virtualizer.options.scrollMargin;\n      /*\n       * Check if the latest virtual items container offset matches with the current offset to determine\n       * if the current offset can be used for scroll restoration.\n       **/\n      const offsetMatched =\n        Number(\n          document\n            .querySelector(`[${offsetAttribute}]`)\n            ?.getAttribute(offsetAttribute)\n        ) === currentTopOffset && typeof currentTopOffset === \"number\";\n\n      /*\n       * Check if all conditions for scroll restoration are satisfied.\n       **/\n      if (\n        requiredItemsLoaded({ virtualizer, scrollIndex, overScan, options }) &&\n        offsetMatched &&\n        !done\n      ) {\n        /*\n         * Check the difference between the last offset of the virtual list container with the current one.\n         * If there is a difference add or subtract from the last scroll offset to determine the normalized scroll restoration offset.\n         **/\n        const offsetDelta = topOffset - currentTopOffset;\n        const scrollToOffset =\n          typeof offsetDelta === \"number\"\n            ? lastScrollOffset - offsetDelta\n            : lastScrollOffset;\n        virtualizer.scrollToOffset(scrollToOffset, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n        if (scrollToOffset !== virtualizer.scrollOffset) {\n          setTimeout(() => {\n            virtualizer.scrollToOffset(scrollToOffset, {\n              align: \"start\",\n              behavior: \"auto\",\n            });\n          }, 0);\n        }\n        storeScrollConfig(scrollConfigStorageKey, {\n          ...scrollConfig,\n          done: true,\n        });\n        setTimeout(() => {\n          removeItemFromScrollConfig(scrollConfigStorageKey);\n        }, 500);\n      }\n    }\n  } catch (error) {\n    console.error(error);\n    removeItemFromScrollConfig(scrollConfigStorageKey);\n  }\n}\n\n/*\n * Restore scroll config\n **/\nfunction restoreScrollConfig(scrollConfigStorageKey?: string): Config | null {\n  try {\n    const config = JSON.parse(\n      sessionStorage.getItem(SCROLL_RESTORATION_CONFIG) || \"\"\n    );\n    return scrollConfigStorageKey ? config[scrollConfigStorageKey] : config;\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}\n\n/*\n * Store scroll restoration configuration\n **/\nfunction storeScrollConfig(scrollConfigStorageKey: string, config: Config) {\n  const currentConfig = restoreScrollConfig();\n  sessionStorage.setItem(\n    SCROLL_RESTORATION_CONFIG,\n    JSON.stringify({\n      ...(currentConfig ? currentConfig : {}),\n      [scrollConfigStorageKey]: config,\n    })\n  );\n}\n\n/*\n * Remove item from scroll config by key\n **/\nfunction removeItemFromScrollConfig(key: string) {\n  const config = restoreScrollConfig();\n\n  if (config) {\n    delete config[key];\n    sessionStorage.setItem(SCROLL_RESTORATION_CONFIG, JSON.stringify(config));\n  }\n}\n\ninterface IItemsLoaded {\n  virtualizer: Virtualizer<Window, Element>;\n  scrollIndex: number;\n  overScan: number;\n  options: VirtualizerOptions<Window, Element>;\n}\n\n/*\n * Check if all required items for scroll restoration are loaded.\n **/\nfunction requiredItemsLoaded({\n  virtualizer,\n  scrollIndex,\n  overScan,\n  options,\n}: IItemsLoaded) {\n  /*\n   * Find the visible item used as a scroll restoration reference.\n   **/\n  const referenceItem = virtualizer\n    .getVirtualItems()\n    .find((virtualItem) => virtualItem.index === scrollIndex);\n\n  /*\n   * Create array of steps to take back from the reference item to check if\n   * the virtual items before it are loaded according to the appropriate size.\n   **/\n  const stepBackArr = Array(overScan)\n    .fill(0)\n    .map((_, index) => index + 1);\n\n  /*\n   * Check if the reference item is loaded according to the appropriate size.\n   **/\n  const referenceItemLoaded =\n    referenceItem &&\n    referenceItem.size >=\n      (options.initialMeasurementsCache?.[referenceItem.index]?.size || 0);\n\n  /*\n   * Check if items before the visible reference item are loaded according to the appropriate size.\n   **/\n  const itemsBeforeReferenceItemLoaded = stepBackArr\n    .map((stepBack) => {\n      const prevItem = virtualizer\n        .getVirtualItems()\n        .find((virtualItem) => virtualItem.index === scrollIndex - stepBack);\n      return prevItem\n        ? prevItem.size >=\n            (options.initialMeasurementsCache?.[prevItem.index]?.size || 0)\n        : true;\n    })\n    .every((item) => item);\n\n  return referenceItemLoaded && itemsBeforeReferenceItemLoaded;\n}\n\nconst getHeaderHeight = ({\n  scrollConfigStorageKey,\n  lastScrollRestorationKey,\n}: {\n  scrollConfigStorageKey: string;\n  lastScrollRestorationKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollConfigStorageKey);\n  if (!scrollConfig || typeof scrollConfig !== \"object\") return null;\n  if (\n    scrollConfig.lastScrollRestorationKey &&\n    lastScrollRestorationKey !== scrollConfig.lastScrollRestorationKey\n  )\n    return null;\n  return typeof scrollConfig.headerHeight === \"number\"\n    ? scrollConfig.headerHeight\n    : null;\n};\n\nconst getInitialMeasurementsCache = ({\n  scrollConfigStorageKey,\n}: {\n  scrollConfigStorageKey: string;\n}) => {\n  const scrollConfig = restoreScrollConfig(scrollConfigStorageKey);\n  if (\n    !scrollConfig ||\n    typeof scrollConfig !== \"object\" ||\n    typeof scrollConfig.options !== \"object\"\n  )\n    return [];\n  return scrollConfig.options.initialMeasurementsCache;\n};\n\n/*\n * Restores the last scroll position\n * @param virtualizer - instance of virtualizer\n **/\nexport function useScrollRestoration({\n  virtualizer,\n  count,\n  overScan,\n  scrollConfigStorageKey,\n  lastScrollRestorationKey,\n  offsetAttribute,\n  headerRef,\n}: ScrollRestoration) {\n  const virtualizerRef = React.useRef(virtualizer);\n  const overScanRef = React.useRef(overScan);\n  const offsetAttributeRef = React.useRef(offsetAttribute);\n  const scrollConfigStorageKeyRef = React.useRef(scrollConfigStorageKey);\n  const lastScrollRestorationKeyRef = React.useRef(lastScrollRestorationKey);\n  const headerHeightRef = React.useRef<number | null>(null);\n\n  React.useEffect(() => {\n    const observer = new ResizeObserver(() => {\n      headerHeightRef.current =\n        headerRef?.current?.getBoundingClientRect()?.height || 0;\n    });\n    if (headerRef?.current) {\n      observer.observe(headerRef.current);\n    }\n    return () => {\n      observer.disconnect();\n    };\n  }, [headerRef]);\n\n  React.useEffect(() => {\n    virtualizerRef.current = virtualizer;\n  }, [virtualizer]);\n\n  React.useEffect(() => {\n    const virtualizer = virtualizerRef.current;\n    const scrollConfig = restoreScrollConfig(scrollConfigStorageKeyRef.current);\n    if (scrollConfig) {\n      const { referenceItemIndex, options, done, lastScrollRestorationKey } =\n        scrollConfig;\n\n      /*\n       * If the current lastScrollRestorationKey and the one before do not match then prevent initiating scroll restoration\n       **/\n      if (\n        lastScrollRestorationKey &&\n        lastScrollRestorationKey !== lastScrollRestorationKeyRef.current\n      ) {\n        removeItemFromScrollConfig(scrollConfigStorageKeyRef.current);\n        return;\n      }\n\n      if (\n        !options ||\n        typeof referenceItemIndex !== \"number\" ||\n        typeof options !== \"object\" ||\n        count < options.count ||\n        done\n      )\n        return;\n\n      /*\n       * Find the index of an item which will be used as a scroll restoration reference.\n       **/\n      const scrollIndex = options.initialMeasurementsCache?.findIndex(\n        (measurementCache) => measurementCache.index === referenceItemIndex\n      );\n      if (scrollIndex && scrollIndex !== -1) {\n        /*\n         * Make sure virtualizer's options from last scroll position are available in the current virtualizer instance\n         * before scrolling to the index of the reference item.\n         **/\n        virtualizer.setOptions({\n          ...virtualizer.options,\n          ...options,\n        });\n        virtualizer.scrollToIndex(scrollIndex, {\n          align: \"start\",\n          behavior: \"auto\",\n        });\n      }\n    }\n  }, [count]);\n\n  React.useEffect(() => {\n    const overScan = overScanRef.current;\n    const scrollConfigStorageKey = scrollConfigStorageKeyRef.current;\n    const lastScrollRestorationKey = lastScrollRestorationKeyRef.current;\n\n    /*\n     * Store scroll restoration configs after unmounting the component where the scroll restoration is used.\n     **/\n    return () => {\n      const lastScrollOffset = virtualizerRef.current?.scrollOffset || 0;\n      /*\n       * Store scroll restoration config only if a scroll occurred\n       **/\n      if (lastScrollOffset > 0) {\n        const headerHeight = headerHeightRef.current;\n        const virtualItems = virtualizerRef.current.getVirtualItems();\n        const stepBackArr = Array(overScan)\n          .fill(0)\n          .map((_, index) => index);\n        /*\n         * Compute a visible item which will be used for scroll restoration reference.\n         **/\n        let visibleItem = null;\n        for (const stepBack of stepBackArr) {\n          if (virtualItems?.[overScan - stepBack]) {\n            visibleItem = virtualItems[overScan - stepBack];\n            break;\n          }\n        }\n        /*\n         * If the index of the visible item is less than or equal to overScan recompute the visible item for accuracy\n         **/\n        if (visibleItem && visibleItem.index <= overScan) {\n          let visibleItemIndex = virtualItems.findIndex(\n            (virtualItem) =>\n              virtualItem.start >= (virtualizerRef.current.scrollOffset || 0)\n          );\n          visibleItemIndex = visibleItemIndex === 0 ? 0 : visibleItemIndex - 1;\n          if (visibleItemIndex >= 0) {\n            visibleItem = virtualItems[visibleItemIndex];\n          }\n        }\n\n        storeScrollConfig(scrollConfigStorageKey, {\n          lastScrollOffset,\n          topOffset:\n            virtualItems?.[0]?.start -\n            virtualizerRef.current.options.scrollMargin,\n          referenceItemIndex: visibleItem?.index || 0,\n          options: {\n            ...virtualizerRef.current?.options,\n            initialMeasurementsCache: virtualizerRef.current?.measurementsCache,\n          },\n          lastScrollRestorationKey,\n          headerHeight: headerHeight || 0,\n        });\n      }\n    };\n  }, []);\n\n  React.useEffect(() => {\n    const scrollConfig = restoreScrollConfig(scrollConfigStorageKeyRef.current);\n\n    /*\n     * Observe changes in the dimension of body element to check scroll position restoration requirements and if all check passes commit the restoration.\n     **/\n    const observer = new ResizeObserver(() => {\n      restoreScrollPosition({\n        virtualizer: virtualizerRef.current,\n        overScan: overScanRef.current,\n        offsetAttribute: offsetAttributeRef.current,\n        scrollConfigStorageKey: scrollConfigStorageKeyRef.current,\n      });\n    });\n    if (scrollConfig) observer.observe(document.body);\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n}\n\nexport {\n  restoreScrollPosition,\n  restoreScrollConfig,\n  getHeaderHeight,\n  getInitialMeasurementsCache,\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "hooks/use-mobile.tsx",
      "content": "import * as React from \"react\";\n\nconst MOBILE_BREAKPOINT = 768;\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\n    undefined\n  );\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    };\n    mql.addEventListener(\"change\", onChange);\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return !!isMobile;\n}\n",
      "type": "registry:hook"
    }
  ]
}